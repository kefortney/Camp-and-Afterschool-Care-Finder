<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>2026 Summer Camp Finder</title>
  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
  <style>
    :root {
      color-scheme: light;
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
    }

    body {
      margin: 0;
      background: #f8fafc;
      color: #0f172a;
    }

    main {
      max-width: 1400px;
      margin: 0 auto;
      padding: 20px;
    }

    h1 {
      margin: 0 0 8px;
      font-size: 1.5rem;
    }

    .subtitle {
      margin: 0 0 16px;
      color: #475569;
      font-size: 0.95rem;
    }

    .toolbar {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 12px;
      margin-bottom: 12px;
      flex-wrap: wrap;
    }

    .search {
      width: min(420px, 100%);
      border: 1px solid #cbd5e1;
      border-radius: 8px;
      padding: 9px 12px;
      font-size: 0.95rem;
    }

    .status {
      color: #334155;
      font-size: 0.9rem;
    }

    .table-wrap {
      background: #fff;
      border: 1px solid #e2e8f0;
      border-radius: 10px;
      overflow: auto;
      max-height: 78vh;
    }

    table {
      width: 100%;
      min-width: 1200px;
      border-collapse: collapse;
      font-size: 0.85rem;
    }

    thead th {
      position: sticky;
      top: 0;
      z-index: 3;
      background: #f1f5f9;
      border-bottom: 1px solid #cbd5e1;
    }

    thead tr.filter-row th {
      top: 36px;
      z-index: 2;
      background: #f8fafc;
      padding: 6px;
    }

    th,
    td {
      border-right: 1px solid #e2e8f0;
      border-bottom: 1px solid #e2e8f0;
      padding: 8px;
      text-align: left;
      vertical-align: top;
    }

    th:last-child,
    td:last-child {
      border-right: none;
    }

    .sort-btn {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      width: 100%;
      border: none;
      background: transparent;
      text-align: left;
      padding: 0;
      font-weight: 600;
      color: #0f172a;
      cursor: pointer;
      font-size: 0.83rem;
    }

    .sort-indicator {
      color: #64748b;
      font-size: 0.72rem;
      white-space: nowrap;
    }

    .filter-input {
      width: 100%;
      border: 1px solid #cbd5e1;
      border-radius: 6px;
      padding: 6px;
      font-size: 0.75rem;
    }

    tbody tr:hover {
      background: #f8fafc;
    }

    a {
      color: #0f4ba8;
    }

    .error {
      color: #b91c1c;
      font-weight: 600;
    }

    .expand-btn {
      margin-left: 6px;
      border: none;
      background: none;
      color: #0f4ba8;
      cursor: pointer;
      padding: 0;
      font-size: 0.8rem;
      text-decoration: underline;
    }
  </style>
</head>
<body>
  <main>
    <h1>2026 Summer Camp Finder</h1>
    <p class="subtitle">Sortable and filterable data table from <strong>data/2026 Summer Camp.csv</strong>.</p>

    <div class="toolbar">
      <input id="globalSearch" class="search" type="text" placeholder="Global search across all columns..." />
      <div id="status" class="status">Loading data...</div>
    </div>

    <div class="table-wrap">
      <table id="campTable" aria-label="Summer camp data table">
        <thead id="tableHead"></thead>
        <tbody id="tableBody"></tbody>
      </table>
    </div>
  </main>

  <script>
    const csvPath = "data/2026%20Summer%20Camp.csv";

    const state = {
      headers: [],
      rows: [],
      filteredRows: [],
      globalFilter: "",
      columnFilters: {},
      sortColumn: null,
      sortDirection: "asc"
    };

    const dropdownFilterHeaders = new Set(["Start Age", "End Age", "Start Grade", "End Grade"]);

    const dom = {
      tableHead: document.getElementById("tableHead"),
      tableBody: document.getElementById("tableBody"),
      status: document.getElementById("status"),
      globalSearch: document.getElementById("globalSearch")
    };

    function normalize(value) {
      return (value ?? "").toString().trim().toLowerCase();
    }

    function parseNumber(value) {
      if (value == null) return Number.NaN;
      const cleaned = String(value).replace(/[$,]/g, "").trim();
      if (!cleaned) return Number.NaN;
      return Number(cleaned);
    }

    function parseDate(value) {
      if (!value) return Number.NaN;
      const date = new Date(value);
      return Number.isNaN(date.getTime()) ? Number.NaN : date.getTime();
    }

    function compareValues(a, b, header) {
      const left = a[header] ?? "";
      const right = b[header] ?? "";

      const numericHeaders = ["Start Age", "End Age", "Start Grade", "End Grade"];
      const dateHeaders = ["Start Date", "End Date"];

      if (numericHeaders.includes(header)) {
        const n1 = parseNumber(left);
        const n2 = parseNumber(right);
        if (!Number.isNaN(n1) && !Number.isNaN(n2)) return n1 - n2;
      }

      if (dateHeaders.includes(header)) {
        const d1 = parseDate(left);
        const d2 = parseDate(right);
        if (!Number.isNaN(d1) && !Number.isNaN(d2)) return d1 - d2;
      }

      return String(left).localeCompare(String(right), undefined, { numeric: true, sensitivity: "base" });
    }

    function isUrl(value) {
      return /^https?:\/\//i.test(String(value || "").trim());
    }

    function appendExpandableText(container, value, maxLength = 150) {
      const text = (value ?? "").toString();
      if (text.length <= maxLength) {
        container.textContent = text;
        return;
      }

      const textSpan = document.createElement("span");
      const toggle = document.createElement("button");
      toggle.type = "button";
      toggle.className = "expand-btn";

      let expanded = false;
      const truncated = `${text.slice(0, maxLength)}...`;

      function render() {
        textSpan.textContent = expanded ? text : truncated;
        toggle.textContent = expanded ? "Less" : "More";
      }

      toggle.addEventListener("click", () => {
        expanded = !expanded;
        render();
      });

      render();
      container.append(textSpan, toggle);
    }

    function applyFiltersAndSort() {
      const globalNeedle = normalize(state.globalFilter);

      let rows = state.rows.filter((row) => {
        const columnMatch = state.headers.every((header) => {
          const filter = normalize(state.columnFilters[header]);
          if (!filter) return true;
          const value = normalize(row[header]);
          if (dropdownFilterHeaders.has(header)) {
            return value === filter;
          }
          return value.includes(filter);
        });

        if (!columnMatch) return false;
        if (!globalNeedle) return true;

        return state.headers.some((header) => normalize(row[header]).includes(globalNeedle));
      });

      if (state.sortColumn) {
        rows = [...rows].sort((a, b) => {
          const result = compareValues(a, b, state.sortColumn);
          return state.sortDirection === "asc" ? result : -result;
        });
      }

      state.filteredRows = rows;
      renderBody();
      dom.status.textContent = `Showing ${rows.length} of ${state.rows.length} rows`;
    }

    function getDropdownOptions(header) {
      const values = new Set();
      state.rows.forEach((row) => {
        const value = (row[header] ?? "").toString().trim();
        if (value) values.add(value);
      });

      return [...values].sort((a, b) => a.localeCompare(b, undefined, { numeric: true, sensitivity: "base" }));
    }

    function renderHead() {
      const headerRow = document.createElement("tr");
      const filterRow = document.createElement("tr");
      filterRow.className = "filter-row";

      state.headers.forEach((header) => {
        const headerCell = document.createElement("th");
        const button = document.createElement("button");
        button.className = "sort-btn";

        const label = document.createElement("span");
        label.textContent = header;

        const indicator = document.createElement("span");
        indicator.className = "sort-indicator";

        if (state.sortColumn === header) {
          indicator.textContent = state.sortDirection === "asc" ? "▲" : "▼";
        } else {
          indicator.textContent = "↕";
        }

        button.append(label, indicator);
        button.addEventListener("click", () => {
          if (state.sortColumn === header) {
            state.sortDirection = state.sortDirection === "asc" ? "desc" : "asc";
          } else {
            state.sortColumn = header;
            state.sortDirection = "asc";
          }
          renderHead();
          applyFiltersAndSort();
        });

        headerCell.appendChild(button);
        headerRow.appendChild(headerCell);

        const filterCell = document.createElement("th");
        if (dropdownFilterHeaders.has(header)) {
          const select = document.createElement("select");
          select.className = "filter-input";

          const anyOption = document.createElement("option");
          anyOption.value = "";
          anyOption.textContent = "All";
          select.appendChild(anyOption);

          getDropdownOptions(header).forEach((optionValue) => {
            const option = document.createElement("option");
            option.value = optionValue;
            option.textContent = optionValue;
            select.appendChild(option);
          });

          select.value = state.columnFilters[header] || "";
          select.addEventListener("change", (event) => {
            state.columnFilters[header] = event.target.value;
            applyFiltersAndSort();
          });

          filterCell.appendChild(select);
        } else {
          const input = document.createElement("input");
          input.className = "filter-input";
          input.placeholder = "Filter...";
          input.value = state.columnFilters[header] || "";
          input.addEventListener("input", (event) => {
            state.columnFilters[header] = event.target.value;
            applyFiltersAndSort();
          });

          filterCell.appendChild(input);
        }

        filterRow.appendChild(filterCell);
      });

      dom.tableHead.replaceChildren(headerRow, filterRow);
    }

    function renderBody() {
      const fragment = document.createDocumentFragment();

      state.filteredRows.forEach((row) => {
        const tr = document.createElement("tr");

        state.headers.forEach((header) => {
          const td = document.createElement("td");
          const value = row[header] ?? "";
          const webpageValue = row["Webpage"] ?? "";

          if ((header === "Camp Description" || header === "Notes" || header === "Registration" || header === "Cost") && String(value).trim()) {
            appendExpandableText(td, value, 150);
          } else if (header === "Organization" && isUrl(webpageValue) && String(value).trim()) {
            const link = document.createElement("a");
            link.href = webpageValue;
            link.target = "_blank";
            link.rel = "noopener noreferrer";
            link.textContent = value;
            td.appendChild(link);
          } else if (isUrl(value)) {
            const link = document.createElement("a");
            link.href = value;
            link.target = "_blank";
            link.rel = "noopener noreferrer";
            link.textContent = value;
            td.appendChild(link);
          } else {
            td.textContent = value;
          }

          tr.appendChild(td);
        });

        fragment.appendChild(tr);
      });

      dom.tableBody.replaceChildren(fragment);
    }

    function initializeTable(data) {
      const headers = data.meta.fields || [];
      const excludedHeaders = new Set(["Consider Further", "Select", "Updated 2026"]);

      const filteredHeaders = headers.filter((header) => normalize(header) !== "" && !excludedHeaders.has(header));
      state.headers = [
        ...filteredHeaders.filter((header) => header === "Organization"),
        ...filteredHeaders.filter((header) => header !== "Organization" && header !== "Webpage")
      ];
      state.rows = data.data.map((row) => {
        const cleaned = { Webpage: row.Webpage ?? "" };
        state.headers.forEach((header) => {
          cleaned[header] = row[header] ?? "";
        });
        return cleaned;
      });

      dom.globalSearch.addEventListener("input", (event) => {
        state.globalFilter = event.target.value;
        applyFiltersAndSort();
      });

      renderHead();
      applyFiltersAndSort();
    }

    Papa.parse(csvPath, {
      download: true,
      header: true,
      skipEmptyLines: true,
      complete: (results) => {
        if (results.errors && results.errors.length > 0) {
          dom.status.innerHTML = `<span class="error">CSV parsed with issues. Check console for details.</span>`;
          console.warn("CSV parse warnings:", results.errors);
        }
        initializeTable(results);
      },
      error: (err) => {
        dom.status.innerHTML = `<span class="error">Failed to load CSV: ${err.message}</span>`;
      }
    });
  </script>
</body>
</html>
